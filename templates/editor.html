<!--
==============================================================================
NEWSLETTER EDITOR PAGE - NYC Records Management System
==============================================================================
This template provides the GrapesJS visual editor interface for creating and editing
newsletter templates. It includes a comprehensive drag-and-drop editor with
newsletter-specific components and CKEditor integration for rich text editing.

Features:
- GrapesJS visual editor with newsletter preset
- CKEditor integration for rich text editing
- Save/Export functionality with SweetAlert2 feedback
- Cloudinary integration for loading existing files
- Custom editor header with file information
- Responsive design for various screen sizes

Template Variables:
- file_id: Cloudinary public_id of the file being edited
- cloud_name: Cloudinary cloud name for loading assets

External Dependencies:
- GrapesJS: Visual page builder framework
- GrapesJS Newsletter Preset: Newsletter-specific components
- CKEditor Plugin: Rich text editing integration
- SweetAlert2: User feedback and alerts

JavaScript APIs Used:
- GrapesJS Editor API: For visual editing
- Cloudinary REST API: For loading/saving files
- Fetch API: For HTTP requests
- Blob API: For file export functionality
==============================================================================
-->
{% extends "base.html" %} 

{% block title %}Newsletter Editor{% endblock %} 

{% block extra_css %}
<!-- ========================================================================
     GRAPESJS AND EDITOR STYLESHEETS
     ======================================================================== -->

<!-- GrapesJS Core Styles: Main editor interface styling -->
<link
  rel="stylesheet"
  href="{{ url_for('static', filename='stylesheets/grapes.min.css') }}"
/>

<!-- Material Design Styles: UI component styling -->
<link
  rel="stylesheet"
  href="{{ url_for('static', filename='stylesheets/material.css') }}"
/>

<!-- Tooltip Styles: Hover tooltips for editor controls -->
<link
  rel="stylesheet"
  href="{{ url_for('static', filename='stylesheets/tooltip.css') }}"
/>

<!-- Demo Styles: Additional styling for demo components -->
<link
  rel="stylesheet"
  href="{{ url_for('static', filename='stylesheets/demos.css') }}"
/>

<!-- ========================================================================
     CUSTOM EDITOR STYLES
     ======================================================================== -->
<style>
  /* ===== NEWSLETTER LINK STYLING ===== */
  .nl-link {
    color: inherit;                     /* Inherit parent text color */
  }

  /* ===== GRAPESJS LOGO CUSTOMIZATION ===== */
  .gjs-logo-version {
    background-color: #5a606d;          /* Custom background for GrapesJS logo */
  }
  
  /* ===== CKEDITOR TOOLBAR STYLING ===== */
  .cke_toolbar.cke_toolbar {
    min-height: 33px;                   /* Minimum height for CKEditor toolbar */
  }

  /* ===== EDITOR HEADER STYLES ===== */
  .editor-header {
    background-color: #2c3e50;          /* Dark blue-gray background */
    color: white;                       /* White text */
    padding: 15px 30px;                 /* Internal spacing */
    display: flex;                      /* Flexbox layout */
    align-items: center;                /* Vertical centering */
    justify-content: space-between;     /* Space between elements */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);  /* Subtle drop shadow */
  }

  /* ===== BACK BUTTON STYLES ===== */
  .back-link {
    color: white;                       /* White text */
    text-decoration: none;              /* Remove underline */
    display: flex;                      /* Flexbox for icon + text */
    align-items: center;                /* Vertical centering */
    padding: 8px 16px;                  /* Internal padding */
    background-color: rgba(255, 255, 255, 0.1);  /* Semi-transparent background */
    border-radius: 6px;                 /* Rounded corners */
    transition: all 0.2s ease;          /* Smooth hover transition */
    font-size: 14px;                    /* Font size */
    font-weight: 500;                   /* Medium font weight */
    min-width: 80px;                    /* Minimum button width */
  }

  .back-link:hover {
    background-color: rgba(255, 255, 255, 0.2);  /* Lighter on hover */
    color: white;                       /* Maintain white text */
    text-decoration: none;              /* No underline on hover */
    transform: translateY(-1px);        /* Slight lift effect */
  }

  .back-link i {
    margin-right: 6px;                  /* Space between icon and text */
    font-size: 16px;                    /* Icon size */
  }

  /* ===== HEADER SPACER FOR LAYOUT BALANCE ===== */
  .header-spacer {
    min-width: 140px;                   /* Match back button width for balance */
    display: flex;
    align-items: center;
    justify-content: flex-end;
  }

  .autosave-status {
    font-size: 12px;
    color: #bdc3c7;
    font-weight: 500;
    letter-spacing: 0.02em;
    white-space: nowrap;
    transition: color 0.2s ease;
  }

  .autosave-status.autosave-status--dirty {
    color: #ffb74d;
  }

  .autosave-status.autosave-status--saving {
    color: #64b5f6;
  }

  .autosave-status.autosave-status--error {
    color: #ef5350;
  }

  .autosave-status.autosave-status--success {
    color: #81c784;
  }

  /* ===== FILENAME DISPLAY ===== */
  .filename-container {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-grow: 1;
  }

</style>
{% endblock %} 

{% block content %}
<!-- ========================================================================
     EDITOR HEADER SECTION
     ======================================================================== -->
<!-- Custom header bar showing file name and navigation controls -->
<div class="editor-header">
  <!-- Back button: Returns to newsletter upload page -->
  <a href="{{ url_for('newsletter.upload') }}" class="back-link">
    <i class="bi bi-arrow-left"></i>
    Back
  </a>
  
  <div class="filename-container" aria-hidden="true"></div>
  
  <!-- Spacer: Provides visual balance for centered file name -->
  <div class="header-spacer">
    <span class="autosave-status" id="autosave-status" role="status" aria-live="polite"></span>
  </div>
</div>


<!-- ========================================================================
     GRAPESJS EDITOR CONTAINER
     ======================================================================== -->
<!-- Main editor container: GrapesJS will replace this div with the full editor interface -->
<!-- Height starts at 0 to prevent flash of unstyled content before editor loads -->
<div id="gjs" style="height: 0px; overflow: hidden"></div>
{% endblock %} {% block extra_js %}
<!-- ========================================================================
     GRAPESJS JAVASCRIPT DEPENDENCIES
     ======================================================================== -->

<!-- GrapesJS Core Library: Main visual page builder framework -->
<script src="{{ url_for('static', filename='js/grapes.min.js') }}"></script>

<!-- CKEditor Plugin: Rich text editing integration for GrapesJS text components -->
<script src="{{ url_for('static', filename='js/grapesjs-plugin-ckeditor/index.js') }}"></script>

<!-- Newsletter Preset: Pre-configured components and styles for email templates -->
<script src="https://unpkg.com/grapesjs-preset-newsletter@1.0.1"></script>

<!-- HTML Processor: Client-side CSS inlining and ID cleanup (replaces juice server) -->
<script src="{{ url_for('static', filename='js/html-processor.js') }}"></script>

<!-- ========================================================================
     GRAPESJS EDITOR INITIALIZATION AND CONFIGURATION
     ======================================================================== -->
<script type="text/javascript">
  // ========================================================================
  // WORD PASTE SANITIZER - Remove Word-specific styles while preserving links
  // ========================================================================
  function sanitizePastedHtml(html) {
    if (!html) {
      return html;
    }

    var wordMarkupPattern = /(class="?Mso|style="[^"]*mso-|<!--\s*\[if\s+gte\s+mso)/i;
    if (!wordMarkupPattern.test(html)) {
      return html;
    }

    var wrapper = document.createElement('div');
    wrapper.innerHTML = html.replace(/<!--\[if[\s\S]*?endif\]-->/gi, '');

    function wrapNodeWithTag(node, tagName) {
      if (!node || node.tagName === tagName.toUpperCase()) {
        return node;
      }
      var replacement = document.createElement(tagName);
      while (node.firstChild) {
        replacement.appendChild(node.firstChild);
      }
      node.parentNode.replaceChild(replacement, node);
      return replacement;
    }

    Array.from(wrapper.querySelectorAll('style, meta, link, script')).forEach(function (node) {
      node.parentNode.removeChild(node);
    });

    Array.from(wrapper.querySelectorAll('o\:p, w\:p, w\:tbl')).forEach(function (node) {
      node.parentNode.removeChild(node);
    });

    Array.from(wrapper.querySelectorAll('*')).forEach(function (node) {
      var originalStyle = node.getAttribute('style');
      if (originalStyle) {
        var styleValue = originalStyle.toLowerCase();

        if (/font-weight\s*:\s*(bold|700|600|800)/.test(styleValue)) {
          node = wrapNodeWithTag(node, 'strong');
        }
        if (/font-style\s*:\s*italic/.test(styleValue)) {
          node = wrapNodeWithTag(node, 'em');
        }
        if (/text-decoration\s*:\s*underline/.test(styleValue)) {
          node = wrapNodeWithTag(node, 'u');
        }
      }

      Array.from(node.attributes).forEach(function (attr) {
        var name = attr.name.toLowerCase();
        var whitelist = {
          a: ['href', 'target', 'title', 'rel']
        };
        var allowed = whitelist[node.tagName ? node.tagName.toLowerCase() : ''] || [];

        if (allowed.indexOf(name) !== -1) {
          if (name === 'href' && !attr.value) {
            node.removeAttribute(attr.name);
          }
          return;
        }

        if (
          name === 'style' ||
          name === 'class' ||
          name === 'id' ||
          name === 'width' ||
          name === 'height' ||
          name === 'align' ||
          name === 'valign' ||
          name === 'lang' ||
          name === 'border' ||
          name === 'color' ||
          name === 'face' ||
          name.indexOf('mso') === 0 ||
          name.indexOf('data-') === 0
        ) {
          node.removeAttribute(attr.name);
        }
      });

      if (node.tagName === 'SPAN' && node.attributes.length === 0) {
        var parent = node.parentNode;
        while (node.firstChild) {
          parent.insertBefore(node.firstChild, node);
        }
        parent.removeChild(node);
      }
    });

    Array.from(wrapper.querySelectorAll('p, span, div')).forEach(function (node) {
      node.style.fontFamily = "Arial, 'Helvetica Neue', Helvetica, sans-serif";
      node.style.fontSize = '16px';
      node.style.lineHeight = '1.5';
    });

    return wrapper.innerHTML;
  }

  function bindCkeditorPasteSanitizer() {
    if (window.__ckeditorPasteSanitizerBound) {
      return;
    }

    if (!window.CKEDITOR) {
      setTimeout(bindCkeditorPasteSanitizer, 200);
      return;
    }

    window.__ckeditorPasteSanitizerBound = true;
    CKEDITOR.on('instanceReady', function (evt) {
      evt.editor.on('paste', function (pasteEvt) {
        if (!pasteEvt || !pasteEvt.data || typeof pasteEvt.data.dataValue !== 'string') {
          return;
        }

        var cleaned = sanitizePastedHtml(pasteEvt.data.dataValue);
        if (cleaned !== pasteEvt.data.dataValue) {
          pasteEvt.data.dataValue = cleaned;
        }
      });
    });
  }

  bindCkeditorPasteSanitizer();

  // Initialize GrapesJS editor with comprehensive configuration
  var editor = grapesjs.init({
    // ===== CORE EDITOR SETTINGS =====
    selectorManager: { componentFirst: true },    // Prioritize component selection over CSS selectors
    clearOnRender: true,                          // Clear canvas on each render for clean state
    height: "100%",                               // Use full container height
    container: "#gjs",                            // Target container element
    fromElement: true,                            // Initialize from existing DOM element
    
    // ===== CANVAS CSS RESETS =====
    // These styles are applied inside the editor canvas to prevent layout issues
    // They do NOT affect the exported HTML
    canvasCss: `
      /* Basic resets for email compatibility */
      html, body { 
        margin: 0 !important; 
        padding: 0 !important; 
        height: auto !important; 
        min-height: 0 !important; 
      }
      
      /* Table resets for email */
      table { 
        border-collapse: collapse; 
        border-spacing: 0; 
      }
      
      /* Preserve original alignment for cells */
      td, th { 
        /* Remove padding reset to preserve original spacing */
        vertical-align: top; 
      }
      
      /* Preserve text alignment - IMPORTANT for logos */
      td[align="center"], th[align="center"],
      td[style*="text-align: center"], td[style*="text-align:center"],
      th[style*="text-align: center"], th[style*="text-align:center"] {
        text-align: center !important;
      }
      
      /* NYC Logo specific - ensure it stays centered */
      img[src*="logo.png"], img[src*="nyc.gov"] {
        margin-left: auto !important;
        margin-right: auto !important;
      }
      
      /* Centered images in centered cells */
      td[align="center"] img, 
      td[style*="text-align: center"] img,
      td[style*="text-align:center"] img {
        margin-left: auto !important;
        margin-right: auto !important;
      }
      
      /* Image handling - be more selective */
      img { 
        border: 0; 
        line-height: 0;
        /* Remove display: block as it can break inline images */
      }
      
      a img { 
        border: 0; 
      }
      
      /* Preserve inline and inline-block elements */
      a, span { 
        /* Preserve original display properties */
      }
      
      /* Social media icons - preserve inline display */
      a[href*="facebook"], a[href*="twitter"], 
      a[href*="instagram"], a[href*="youtube"],
      a[href*="tumblr"], a[href*="linkedin"] {
        display: inline-block !important;
      }
      
      /* Clear floats in case any column blocks rely on floats */
      .gjs-row::after, .row::after, .columns::after { 
        content: ""; 
        display: table; 
        clear: both; 
      }
    `,
    
    // ===== LOCAL STORAGE CONFIGURATION =====
    storageManager: {
      options: {
        local: { key: "gjsProjectNl" },           // Local storage key for auto-save
      },
    },
    
    // ===== PLUGIN CONFIGURATION =====
    plugins: ["grapesjs-preset-newsletter", "grapesjs-plugin-ckeditor"],
    
    // ===== PLUGIN-SPECIFIC OPTIONS =====
    pluginsOpts: {
      // --- Newsletter Preset Configuration ---
      "grapesjs-preset-newsletter": {
        modalLabelImport: "Paste all your code here below and click import",
        modalLabelExport: "Copy the code and use it wherever you want",
        codeViewerTheme: "material",              // Material theme for code viewer
        importPlaceholder:                        // Default content for new newsletters
          '<table class="table"><tr><td class="cell">Hello world!</td></tr></table>',
        // Minimize default cell styles to preserve original template styles
        cellStyle: {                              
          "vertical-align": "top",
          // Remove default font, color, margin, padding to preserve originals
        },
        // Don't reset styles on import
        resetStyleManager: false,
        // Preserve inline styles
        inlineCss: false,
      },
      
      // --- CKEditor Rich Text Plugin Configuration ---
      "grapesjs-plugin-ckeditor": {
        onToolbar: (el) => {
          el.style.minWidth = "350px";            // Ensure toolbar has minimum width
        },
        options: {
          startupFocus: true,                     // Auto-focus editor on load
          extraAllowedContent: "a[!href,target,title,rel]",   // Allow anchor attributes while filtering Word styles
          allowedContent: true,                   // Disable auto-formatting and class removal
          enterMode: 2,                           // Use <br> tags instead of <p> for line breaks
          extraPlugins: "sharedspace,justify,colorbutton,panelbutton,font",  // Additional CKEditor plugins
          versionCheck: false,                    // Disable version checking
          pasteFromWordRemoveFontStyles: true,          // Strip font metadata from Word paste
          pasteFromWordRemoveStyles: true,               // Remove inline styling from Word paste
          forcePasteAsPlainText: false,                  // Keep hyperlinks and structural markup
          removeFormatAttributes: "style lang width height color align", // Additional cleanup for paste
          
          // --- CKEditor Toolbar Configuration ---
          toolbar: [
            { name: "styles", items: ["Font", "FontSize"] },                    // Font family and size
            ["Bold", "Italic", "Underline", "Strike"],                         // Text formatting
            { name: "paragraph", items: ["NumberedList", "BulletedList"] },    // Lists
            { name: "links", items: ["Link", "Unlink"] },                      // Hyperlinks
            { name: "colors", items: ["TextColor", "BGColor"] },               // Text and background colors
          ],
        },
        // Filter out inline elements (span) that CKEditor doesn't support in inline mode
        customRte: {
          enable: function(el, rte) {
            // CKEditor inline mode only supports block-level elements
            // Skip span, a, strong, em, and other inline elements to prevent errors
            const inlineElements = ['SPAN', 'A', 'STRONG', 'EM', 'B', 'I', 'U', 'STRIKE'];
            if (inlineElements.includes(el.tagName)) {
              // Make element editable without CKEditor for inline elements
              el.contentEditable = true;
              return null; // Don't activate CKEditor
            }
            // For block elements, let the plugin handle CKEditor initialization normally
            return undefined;
          },
          disable: function(el, rte) {
            el.contentEditable = false;
            if (rte && rte.destroy) {
              rte.destroy();
            }
          }
        }
      },
    },
  });

  // ===== EDITOR API REFERENCES =====
  var pnm = editor.Panels;        // Panel manager for adding custom toolbar buttons
  var cmdm = editor.Commands;     // Command manager for defining custom actions

  var blockManager = editor.BlockManager;  // Block manager for drag-and-drop blocks

  // ========================================================================
  // COMPONENT TYPE REGISTRATION - Register custom component types for editability
  // ========================================================================

  // Register text-cell component to make table cells editable
  editor.DomComponents.addType('text-cell', {
    isComponent: el => {
      if (el.tagName === 'TD') {
        const hasText = el.textContent && el.textContent.trim().length > 0;
        const hasNoTables = !el.querySelector('table');
        return hasText && hasNoTables;
      }
      return false;
    },
    model: {
      defaults: {
        editable: true,
        droppable: true,
        traits: ['id', 'title'],
        attributes: { 'data-gjs-type': 'text' }
      }
    }
  });

  // ========================================================================
  // COMPONENT MOUNT HANDLER - Ensure editability at runtime
  // ========================================================================

  editor.on('component:mount', (component) => {
    const tagName = component.get('tagName')?.toLowerCase();
    const el = component.getEl();

    // Make text containers editable on mount
    if (['td', 'th', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div'].includes(tagName)) {
      if (el && el.textContent && el.textContent.trim().length > 0) {
        const hasNoTables = !el.querySelector('table');
        const hasNoImages = !el.querySelector('img');

        if (hasNoTables && hasNoImages) {
          component.set('editable', true);
          component.set('type', 'text');
          console.log('[EDITABILITY] Made component editable on mount:', tagName, el.textContent.substring(0, 30) + '...');
        }
      }
    }
  });

  const fileId = "{{ file_id }}";              // File identifier shared across save routines

  function ensureHtmlExtension(name) {
    if (!name) {
      return 'newsletter.html';
    }
    return /\.html?$/i.test(name) ? name : `${name}.html`;
  }

  function getCurrentFileName() {
    if (fileId) {
      const segment = fileId.split('/').pop();
      if (segment) {
        return ensureHtmlExtension(segment);
      }
    }
    return 'newsletter.html';
  }

  document.title = 'Newsletter Editor';

  const AUTOSAVE_DELAY = 1500;
  const AUTOSAVE_RETRY_DELAY = 5000;

  let autosaveTimer = null;
  let autosaveEnabled = false;
  let isSaving = false;
  let pendingSave = false;
  let hasPendingChanges = false;
  let lastSavedSnapshot = null;

  const autosaveStatusEl = document.getElementById('autosave-status');

  function setAutosaveStatus(message, state) {
    if (!autosaveStatusEl) {
      return;
    }

    autosaveStatusEl.textContent = message;

    const stateClasses = [
      'autosave-status--dirty',
      'autosave-status--saving',
      'autosave-status--error',
      'autosave-status--success',
    ];

    stateClasses.forEach((cls) => autosaveStatusEl.classList.remove(cls));

    if (state) {
      autosaveStatusEl.classList.add(`autosave-status--${state}`);
    }
  }

  function buildSavePayload() {
    if (!editor) {
      return { fullHtml: '', snapshot: '' };
    }

    // Get clean HTML for email sending
    let html = editor.getHtml();
    html = ensureAlignmentStyles(html);         // Preserve alignment before saving

    const css = editor.getCss();
    const fullHtml = `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style>${css}</style>
</head>
<body>${html}</body>
</html>`;

    // DUAL EXPORT STRATEGY: Save editor version with data-gjs-* attributes
    // This allows re-editing without losing component types
    const editorHtml = editor.getHtml({ withProps: true });
    const editorFullHtml = `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style>${css}</style>
</head>
<body>${editorHtml}</body>
</html>`;

    // Store editor version in localStorage for re-editing
    try {
      localStorage.setItem('newsletter_editor_html', editorHtml);
      localStorage.setItem('newsletter_editor_css', css);
      localStorage.setItem('newsletter_editor_full', editorFullHtml);
    } catch (e) {
      console.warn('Could not save editor version to localStorage:', e);
    }

    return {
      fullHtml,
      snapshot: fullHtml.trim(),
    };
  }

  async function performSave() {
    if (!fileId) {
      console.warn('Cannot save without a file identifier.');
      hasPendingChanges = false;
      return { saved: false, skipped: true };
    }

    if (isSaving) {
      return { saved: false, skipped: true, deferred: true };
    }

    const { fullHtml, snapshot } = buildSavePayload();

    if (!snapshot || (lastSavedSnapshot && snapshot === lastSavedSnapshot)) {
      hasPendingChanges = false;
      return { saved: false, skipped: true };
    }

    isSaving = true;

    try {
      const response = await fetch(`/save/${fileId}`, {
        method: "POST",
        headers: {
          "Content-Type": "text/html",
        },
        body: fullHtml,
      });

      if (!response.ok) {
        throw new Error(`Save request failed with status ${response.status}`);
      }

      lastSavedSnapshot = snapshot;
      hasPendingChanges = false;

      return { saved: true, skipped: false };
    } catch (error) {
      hasPendingChanges = true;
      throw error;
    } finally {
      isSaving = false;

      if (pendingSave) {
        pendingSave = false;
        if (autosaveEnabled) {
          scheduleAutosave(AUTOSAVE_DELAY);
        }
      }
    }
  }

  function scheduleAutosave(delay = AUTOSAVE_DELAY) {
    if (!autosaveEnabled) {
      hasPendingChanges = true;
      return;
    }

    hasPendingChanges = true;
    setAutosaveStatus('Unsaved changes...', 'dirty');

    if (isSaving) {
      pendingSave = true;
      return;
    }

    if (autosaveTimer) {
      clearTimeout(autosaveTimer);
    }

    if (delay <= 0) {
      triggerAutosave();
      return;
    }

    autosaveTimer = window.setTimeout(triggerAutosave, delay);
  }

  function triggerAutosave() {
    if (!autosaveEnabled) {
      return;
    }

    if (autosaveTimer) {
      clearTimeout(autosaveTimer);
      autosaveTimer = null;
    }

    setAutosaveStatus('Saving...', 'saving');

    performSave()
      .then(({ saved, skipped }) => {
        if (skipped) {
          setAutosaveStatus('All changes saved', 'success');
          return;
        }

        setAutosaveStatus('Saved just now', 'success');

        window.setTimeout(() => {
          if (!hasPendingChanges) {
            setAutosaveStatus('All changes saved', 'success');
          }
        }, 2500);
      })
      .catch((error) => {
        console.error('Autosave failed:', error);
        setAutosaveStatus('Autosave failed. Retrying...', 'error');

        if (autosaveEnabled) {
          autosaveTimer = window.setTimeout(triggerAutosave, AUTOSAVE_RETRY_DELAY);
        }
      });
  }

  function initializeAutosaveBaseline() {
    setAutosaveStatus('Preparing autosave...', 'saving');

    window.setTimeout(() => {
      const { snapshot } = buildSavePayload();
      lastSavedSnapshot = snapshot;
      hasPendingChanges = false;
      autosaveEnabled = true;
      setAutosaveStatus('All changes saved', 'success');
    }, 500);
  }

  const autosaveTrackedEvents = [
    'update',
    'component:add',
    'component:remove',
    'component:update',
    'component:styleUpdate',
    'asset:add',
    'asset:remove',
    'asset:upload:response',
    'style:change',
    'canvas:drop-end',
  ];

  autosaveTrackedEvents.forEach((eventName) => {
    editor.on(eventName, () => scheduleAutosave());
  });

  window.addEventListener('beforeunload', (event) => {
    if (isSaving || hasPendingChanges) {
      event.preventDefault();
      event.returnValue = 'Your recent changes might not be saved yet. Do you want to leave?';
    }
  });

  blockManager.add('image-caption-block', {
    label: 'Image + Caption',
    category: 'Media',
    media: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
      <rect x="6" y="6" width="52" height="36" rx="4" ry="4" fill="#e3f2fd" stroke="#1565c0" stroke-width="2" />
      <path d="M14 34l10-12 11 15 7-9 14 18H14z" fill="#1565c0" opacity="0.55" />
      <circle cx="26" cy="20" r="4" fill="#1565c0" />
      <rect x="12" y="48" width="40" height="4" rx="2" fill="#0d47a1" />
      <rect x="18" y="54" width="28" height="4" rx="2" fill="#0d47a1" opacity="0.7" />
    </svg>`,
    content: `
      <table class="image-caption-block" cellpadding="0" cellspacing="0" role="presentation" style="width:100%; text-align:center;">
        <tbody>
          <tr>
            <td style="padding: 12px;">
              <img data-gjs-type="image" src="https://placehold.co/600x350/1565c0/ffffff?text=Image" alt="Newsletter image" style="display:block; width:100%; max-width:600px; margin:0 auto 8px; border-radius:4px;" />
              <p data-gjs-type="text" style="margin:0; color:#4a4a4a; line-height:1.5; font-family:inherit; font-size:inherit; font-style:italic;">Add a descriptive caption here</p>
            </td>
          </tr>
        </tbody>
      </table>
    `,
    select: true,
  });

  blockManager.add('image-left-text-block', {
    label: 'Image Left + Text',
    category: 'Media',
    media: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
      <rect x="4" y="8" width="24" height="48" rx="3" fill="#90caf9" stroke="#1565c0" stroke-width="2" />
      <rect x="34" y="12" width="26" height="6" rx="2" fill="#1565c0" />
      <rect x="34" y="24" width="22" height="6" rx="2" fill="#1565c0" opacity="0.8" />
      <rect x="34" y="36" width="18" height="6" rx="2" fill="#1565c0" opacity="0.6" />
      <rect x="34" y="48" width="22" height="6" rx="2" fill="#1565c0" opacity="0.4" />
    </svg>`,
    content: `
      <table class="image-left-text-block" cellpadding="0" cellspacing="0" role="presentation" style="width:100%;">
        <tbody>
          <tr>
            <td width="40%" style="padding: 12px; vertical-align: top;">
              <img data-gjs-type="image" src="https://placehold.co/260x260/0d47a1/ffffff?text=Image" alt="Feature image" style="display:block; width:100%; max-width:260px; border-radius:6px;" />
            </td>
            <td width="60%" style="padding: 12px 12px 12px 16px; vertical-align: top;">
              <h3 data-gjs-type="text" style="margin:0 0 8px; font-size:14px; color:#000000; font-family:inherit;">Headline Title</h3>
              <p data-gjs-type="text" style="margin:0; color:#4a4a4a; line-height:1.6; font-family:inherit; font-size:inherit;">Add supporting copy next to the image. Keep paragraphs concise and scannable for email clients.</p>
            </td>
          </tr>
        </tbody>
      </table>
    `,
    select: true,
  });

  blockManager.add('image-right-text-block', {
    label: 'Image Right + Text',
    category: 'Media',
    media: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
      <rect x="36" y="8" width="24" height="48" rx="3" fill="#90caf9" stroke="#1565c0" stroke-width="2" />
      <rect x="4" y="12" width="26" height="6" rx="2" fill="#1565c0" />
      <rect x="8" y="24" width="22" height="6" rx="2" fill="#1565c0" opacity="0.8" />
      <rect x="12" y="36" width="18" height="6" rx="2" fill="#1565c0" opacity="0.6" />
      <rect x="8" y="48" width="22" height="6" rx="2" fill="#1565c0" opacity="0.4" />
    </svg>`,
    content: `
      <table class="image-right-text-block" cellpadding="0" cellspacing="0" role="presentation" style="width:100%;">
        <tbody>
          <tr>
            <td width="60%" style="padding: 12px 16px 12px 12px; vertical-align: top;">
              <h3 data-gjs-type="text" style="margin:0 0 8px; font-size:14px; color:#000000; font-family:inherit;">Highlight Title</h3>
              <p data-gjs-type="text" style="margin:0; color:#4a4a4a; line-height:1.6; font-family:inherit; font-size:inherit;">Share your supporting copy here so readers can skim the key details before exploring the image on the right.</p>
            </td>
            <td width="40%" style="padding: 12px; vertical-align: top;">
              <img data-gjs-type="image" src="https://placehold.co/260x260/0d47a1/ffffff?text=Image" alt="Feature image" style="display:block; width:100%; max-width:260px; border-radius:6px;" />
            </td>
          </tr>
        </tbody>
      </table>
    `,
    select: true,
  });

  blockManager.add('bullet-list-block', {
    label: 'Bulleted Highlights',
    category: 'Content',
    media: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
      <rect x="8" y="12" width="48" height="40" rx="6" fill="#e3f2fd" stroke="#1565c0" stroke-width="2" />
      <circle cx="20" cy="26" r="3" fill="#1565c0" />
      <rect x="26" y="24" width="22" height="4" rx="2" fill="#1565c0" opacity="0.8" />
      <circle cx="20" cy="36" r="3" fill="#1565c0" />
      <rect x="26" y="34" width="18" height="4" rx="2" fill="#1565c0" opacity="0.65" />
      <circle cx="20" cy="46" r="3" fill="#1565c0" />
      <rect x="26" y="44" width="24" height="4" rx="2" fill="#1565c0" opacity="0.5" />
    </svg>`,
    content: `
      <table class="bullet-list-block" cellpadding="0" cellspacing="0" role="presentation" style="width:100%;">
        <tbody>
          <tr>
            <td style="padding: 20px 24px;">
              <h3 data-gjs-type="text" style="margin:0 0 8px; font-size:18px; color:#000000; font-family:inherit;">Key Highlights</h3>
              <p data-gjs-type="text" style="margin:0 0 12px; color:#4a4a4a; line-height:1.6; font-family:inherit; font-size:inherit;">Use this section to summarize important updates or takeaways your readers should remember.</p>
              <ul data-gjs-type="text" style="margin:0; padding-left:20px; color:#37474f; line-height:1.6; font-family:inherit; font-size:inherit;">
                <li>Lead with a concise, action-oriented highlight for readers.</li>
                <li>Explain why the update matters or what the next step is.</li>
                <li>Offer supporting data, dates, or links where relevant.</li>
              </ul>
            </td>
          </tr>
        </tbody>
      </table>
    `,
    select: true,
  });

  blockManager.add('text-divider-block', {
    label: 'Text Divider',
    category: 'Content',
    media: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
      <rect x="6" y="30" width="52" height="6" rx="3" fill="#000" />
    </svg>`,
    content: `
      <table class="text-divider-block" cellpadding="0" cellspacing="0" role="presentation" style="width:100%;">
        <tbody>
          <tr>
            <td style="padding: 20px 24px;">
              <hr style="border:none; border-top:2px solid #000000; margin:0 auto 20px; width:100%; max-width:640px;" />
            </td>
          </tr>
        </tbody>
      </table>
    `,
    select: true,
  });

  editor.addStyle(`
    .image-caption-block img {
      display: block;
      width: 100%;
      height: auto;
      margin: 0 auto 8px;
      border-radius: 4px;
    }
    .image-caption-block p {
      font-family: inherit;
      font-size: inherit;
      color: #4a4a4a;
      line-height: 1.5;
      margin: 0;
      font-style: italic;
    }
    .image-left-text-block {
      width: 100%;
    }
    .image-left-text-block td {
      vertical-align: top;
    }
    .image-left-text-block img {
      display: block;
      width: 100%;
      height: auto;
      border-radius: 6px;
    }
    .image-left-text-block h3 {
      font-family: inherit;
      margin: 0 0 8px;
      font-size: 14px;
      color: #000000;
    }
    .image-left-text-block p {
      font-family: inherit;
      margin: 0;
      font-size: inherit;
      line-height: 1.6;
      color: #4a4a4a;
    }
    .image-right-text-block {
      width: 100%;
    }
    .image-right-text-block td {
      vertical-align: top;
    }
    .image-right-text-block img {
      display: block;
      width: 100%;
      height: auto;
      border-radius: 6px;
    }
    .image-right-text-block h3 {
      font-family: inherit;
      margin: 0 0 8px;
      font-size: 14px;
      color: #000000;
    }
    .image-right-text-block p {
      font-family: inherit;
      margin: 0;
      font-size: inherit;
      line-height: 1.6;
      color: #4a4a4a;
    }
    .bullet-list-block li {
      margin-bottom: 8px;
    }
    .bullet-list-block li:last-child {
      margin-bottom: 0;
    }
    .text-divider-block hr {
      border: none;
      border-top: 2px solid #000000;
      width: 100%;
      max-width: 640px;
      margin: 20px auto;
    }
    @media only screen and (max-width: 600px) {
      .image-left-text-block tr {
        display: block;
      }
      .image-left-text-block td {
        display: block;
        width: 100% !important;
        padding: 8px !important;
      }
      .image-right-text-block tr {
        display: block;
      }
      .image-right-text-block td {
        display: block;
        width: 100% !important;
        padding: 8px !important;
      }
    }
  `);
  // ========================================================================
  // CSS SANITIZER - Remove problematic styles for email compatibility
  // ========================================================================
  function sanitizeCssForEmail(css) {
    let sanitized = css;
    
    // Remove height/min-height on body/html/wrapper to prevent post-save canvas inflation
    const blockedSelectors = ['body', 'html', '#wrapper', '.wrapper'];
    
    blockedSelectors.forEach(selector => {
      // Create regex to match the selector and its rules
      const regex = new RegExp(`${selector.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\{[^}]*\\}`, 'gi');
      
      sanitized = sanitized.replace(regex, (match) => {
        // Remove problematic height properties while preserving other styles
        return match
          .replace(/(?:min-)?height\s*:\s*[^;]+;?/gi, '')
          .replace(/padding-bottom\s*:\s*[^;]+;?/gi, '');
      });
    });
    
    // Remove any 100vh values which are problematic in email clients
    sanitized = sanitized.replace(/(?:min-)?height\s*:\s*100vh;?/gi, '');
    
    return sanitized;
  }
  
  // ========================================================================
  // ENSURE ALIGNMENT STYLES - Add critical alignment styles for logos/icons
  // ========================================================================
  function ensureAlignmentStyles(html) {
    // Parse HTML to add necessary inline styles
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Find all centered table cells and ensure text-align is inline
    const centeredCells = doc.querySelectorAll('td[align="center"], th[align="center"]');
    centeredCells.forEach(cell => {
      const style = cell.getAttribute('style') || '';
      if (!style.includes('text-align')) {
        cell.setAttribute('style', style + (style ? '; ' : '') + 'text-align: center');
      }
    });
    
    // Find NYC logo and ensure it's centered
    const logos = doc.querySelectorAll('img[src*="logo.png"], img[src*="nyc.gov"]');
    logos.forEach(logo => {
      const style = logo.getAttribute('style') || '';
      if (!style.includes('margin')) {
        logo.setAttribute('style', style + (style ? '; ' : '') + 'margin: 0 auto; display: block');
      }
      // Also ensure parent cell is centered
      const parentCell = logo.closest('td, th');
      if (parentCell && !parentCell.getAttribute('align')) {
        parentCell.setAttribute('align', 'center');
        const parentStyle = parentCell.getAttribute('style') || '';
        if (!parentStyle.includes('text-align')) {
          parentCell.setAttribute('style', parentStyle + (parentStyle ? '; ' : '') + 'text-align: center');
        }
      }
    });
    
    // Ensure social media icons stay inline
    const socialLinks = doc.querySelectorAll('a[href*="facebook"], a[href*="twitter"], a[href*="instagram"], a[href*="youtube"], a[href*="tumblr"], a[href*="linkedin"]');
    socialLinks.forEach(link => {
      const style = link.getAttribute('style') || '';
      if (!style.includes('display')) {
        link.setAttribute('style', style + (style ? '; ' : '') + 'display: inline-block');
      }
    });
    
    // Return the body innerHTML
    return doc.body.innerHTML;
  }

  // ========================================================================
  // SAVE PROJECT COMMAND - Save current editor content to server
  // ========================================================================
  cmdm.add("save-project", {
    run: async function (editor, sender) {
      sender.set("active", 0);                    // Deactivate button after click
      
      // --- Show Loading State ---
      Swal.fire({
        title: 'Saving Project...',
        text: 'Please wait while we save your project',
        allowOutsideClick: false,
        allowEscapeKey: false,
        didOpen: () => {
          Swal.showLoading();
        }
      });
      
      setAutosaveStatus('Saving...', 'saving');
      
      try {
        const result = await performSave();
        
        if (result.deferred) {
          setAutosaveStatus('Autosave in progress...', 'saving');
          Swal.fire({
            icon: 'info',
            title: 'Save In Progress',
            text: 'An autosave is already running. Your changes will be saved momentarily.',
            confirmButtonColor: '#10b981'
          });
          return;
        }
        
        Swal.fire({
          icon: 'success',
          title: 'Success!',
          text: result.skipped ? 'No changes detected. All updates are already saved.' : 'Project saved successfully!',
          timer: 2000,                          // Auto-close after 2 seconds
          showConfirmButton: false
        });
        
        if (result.skipped) {
          setAutosaveStatus('All changes saved', 'success');
        } else {
          setAutosaveStatus('Saved just now', 'success');
          window.setTimeout(() => {
            if (!hasPendingChanges) {
              setAutosaveStatus('All changes saved', 'success');
            }
          }, 2500);
        }
      } catch (error) {
        console.error('Manual save failed:', error);
        Swal.fire({
          icon: 'error',
          title: 'Error!',
          text: 'Failed to save project. Please try again.',
          confirmButtonColor: '#d33'              // Red confirm button
        });
        setAutosaveStatus('Save failed. Please retry.', 'error');
      }
    },
  });
  // ========================================================================
  // ADD SAVE BUTTON TO TOOLBAR - Custom save button in GrapesJS toolbar
  // ========================================================================
  pnm.addButton("options", [
    {
      id: "save-db",                              // Unique button identifier
      label: `<svg style="display: block; max-width: 22px" viewBox="0 0 24 24">
            <path fill="currentColor" d="M17,3H5C3.89,3 3,3.89 3,5V19C3,20.11 3.9,21 5,21H19C20.11,21 21,20.11 21,19V7L17,3M19,19H5V5H16.17L19,7.83V19M12,12C10.34,12 9,13.34 9,15C9,16.66 10.34,18 12,18C13.66,18 15,16.66 15,15C15,13.34 13.66,12 12,12M6,6H15V10H6V6Z" />
        </svg>`,                                  // Save icon SVG
      command: "save-project",                    // Links to save command defined above
      attributes: {
        title: "Save Project",                   // Tooltip text
        "data-tooltip-pos": "bottom",            // Tooltip position
      },
    },
  ]);

  // ========================================================================
  // EXPORT HTML COMMAND - Process with client-side HTML processor and download
  // ========================================================================
  cmdm.add("export-html", {
    run: async function (editor, sender) {
      sender.set("active", 0);                    // Deactivate button after click
      
      // --- Show Loading State ---
      Swal.fire({
        title: 'Exporting HTML...',
        text: 'Please wait while we process and export your HTML file',
        allowOutsideClick: false,
        allowEscapeKey: false,
        didOpen: () => {
          Swal.showLoading();
        }
      });
      
      try {
        // --- DUAL EXPORT STRATEGY - ENHANCED ---
        // Save editor version with data-gjs-* attributes for re-editing
        const rawEditorHtml = editor.getHtml();
        const editorCss = editor.getCss();

        // Manually add editability markers to editor version
        const parser = new DOMParser();
        const editorDoc = parser.parseFromString(rawEditorHtml, 'text/html');

        // Mark all editable elements in the editor version
        editorDoc.querySelectorAll('td, th, p, h1, h2, h3, h4, h5, h6, div').forEach(el => {
          const hasText = el.textContent && el.textContent.trim().length > 0;
          const hasNoTables = !el.querySelector('table');
          const hasNoImages = !el.querySelector('img');
          const notPreview = !el.hasAttribute('aria-hidden');

          if (hasText && hasNoTables && hasNoImages && notPreview) {
            el.setAttribute('data-gjs-type', 'text');
            el.setAttribute('data-gjs-editable', 'true');
          }
        });

        const markedEditorHtml = editorDoc.documentElement.outerHTML;

        try {
          localStorage.setItem('newsletter_editor_html', markedEditorHtml);
          localStorage.setItem('newsletter_editor_css', editorCss);
          console.log('[EDITABILITY] Saved editor version with markers to localStorage');
        } catch (e) {
          console.warn('[EDITABILITY] Could not save editor version to localStorage:', e);
        }

        // --- Extract Content from Editor ---
        let html = editor.getHtml();                // Get clean HTML for email
        const rawCss = editorCss;                   // Use same CSS
        const css = sanitizeCssForEmail(rawCss);    // Sanitize CSS for email compatibility

        // --- Ensure alignment styles are preserved BEFORE processing ---
        html = ensureAlignmentStyles(html);         // Add inline styles for logos/icons
        
        // --- Add critical email CSS for social icons and logo ---
        const criticalCss = `
          /* Preserve social media icon alignment */
          a[href*="facebook"] img,
          a[href*="twitter"] img,
          a[href*="instagram"] img,
          a[href*="youtube"] img,
          a[href*="tumblr"] img,
          a[href*="linkedin"] img {
            display: inline-block !important;
          }
          
          /* Preserve NYC logo centering */
          img[src*="logo.png"],
          img[src*="nyc.gov"] {
            display: block !important;
            margin: 0 auto !important;
          }
          
          /* Ensure social links stay inline */
          a[href*="facebook"],
          a[href*="twitter"],
          a[href*="instagram"],
          a[href*="youtube"],
          a[href*="tumblr"],
          a[href*="linkedin"] {
            display: inline-block !important;
            text-decoration: none !important;
          }
          
          ${css}
        `;
        
        // --- Construct Complete HTML Document ---
        const fullHtml = `<!doctype html><html><head><style>${criticalCss}</style></head><body>${html}</body></html>`;
        
        // --- Format HTML before processing ---
        let formattedHtml = fullHtml;
        try {
          // Format the HTML for better readability
          formattedHtml = formatHtml(fullHtml);
        } catch (formatError) {
          console.warn('HTML formatting failed, using unformatted:', formatError);
          // Continue with unformatted HTML
        }
        
        // --- Process HTML with Client-side Processor ---
        const exportFilename = getCurrentFileName();
        const result = window.HTMLProcessor.processAndDownload(formattedHtml, exportFilename);
        
        if (!result.success) {
          throw new Error(result.error);
        }
        
        // --- Show Success Feedback ---
        Swal.fire({
          icon: 'success',
          title: 'Export Complete!',
          text: 'HTML file processed and exported successfully!',
          timer: 2000,                              // Auto-close after 2 seconds
          showConfirmButton: false
        });
        
      } catch (error) {
        // --- Show Error Feedback ---
        console.error('Export error:', error);
        Swal.fire({
          icon: 'error',
          title: 'Export Failed!',
          text: `Failed to process HTML: ${error.message}`,
          confirmButtonColor: '#d33'
        });
      }
    },
  });
  // ========================================================================
  // ADD EXPORT BUTTON TO TOOLBAR - Custom export button in GrapesJS toolbar
  // ========================================================================
  pnm.addButton("options", [
    {
      id: "export-file",                          // Unique button identifier
      label: `<svg style="display: block; max-width: 22px" viewBox="0 0 24 24">
            <path fill="currentColor" d="M14,2H6C4.9,2 4,2.9 4,4V20C4,21.1 4.9,22 6,22H18C19.1,22 20,21.1 20,20V8L14,2M18,20H6V4H13V9H18V20M12,19L8,15H11V12H13V15H16L12,19Z" />
        </svg>`,                                  // Export/download icon SVG
      command: "export-html",                     // Links to export command defined above
      attributes: {
        title: "Export HTML",                    // Tooltip text
        "data-tooltip-pos": "bottom",            // Tooltip position
      },
    },
  ]);

  // ========================================================================
  // HTML FORMATTER - Format HTML with proper indentation
  // ========================================================================
  function formatHtml(html) {
    // Basic HTML formatter (similar to Prettier)
    // This provides proper indentation and formatting
    
    let formatted = html;
    let indentLevel = 0;
    const indent = '  '; // 2 spaces
    
    // First, ensure doctype is on its own line
    formatted = formatted.replace(/<!DOCTYPE[^>]*>/gi, (match) => {
      return match + '\n';
    });
    
    // Add newlines before and after tags
    formatted = formatted.replace(/>\s*</g, '>\n<');
    
    // Split into lines
    const lines = formatted.split('\n');
    const formattedLines = [];
    
    // Track if we're inside certain tags that shouldn't be formatted
    let inPreTag = false;
    let inScriptTag = false;
    let inStyleTag = false;
    
    for (let line of lines) {
      line = line.trim();
      if (!line) continue;
      
      // Check for pre, script, style tags
      if (line.match(/<pre[^>]*>/i)) inPreTag = true;
      if (line.match(/<\/pre>/i)) inPreTag = false;
      if (line.match(/<script[^>]*>/i)) inScriptTag = true;
      if (line.match(/<\/script>/i)) inScriptTag = false;
      if (line.match(/<style[^>]*>/i)) inStyleTag = true;
      if (line.match(/<\/style>/i)) inStyleTag = false;
      
      // Skip formatting for pre, script, style content
      if (inPreTag || inScriptTag || inStyleTag) {
        formattedLines.push(line);
        continue;
      }
      
      // Handle closing tags
      if (line.match(/^<\//)) {
        indentLevel = Math.max(0, indentLevel - 1);
      }
      
      // Add proper indentation
      const indentStr = indent.repeat(indentLevel);
      formattedLines.push(indentStr + line);
      
      // Handle opening tags (but not self-closing)
      if (line.match(/^<[^/][^>]*[^/]>/) && !line.match(/^<(img|br|hr|input|meta|link|area|base|col|embed|source|track|wbr)\b/i)) {
        // Check if this is not a self-closing tag or void element
        if (!line.match(/\/>$/)) {
          indentLevel++;
        }
      }
      
      // Handle self-closing tags that might have been split
      if (line.match(/\/>$/)) {
        // Don't increase indent for self-closing tags
      }
    }
    
    // Join lines back together
    formatted = formattedLines.join('\n');
    
    // Clean up extra blank lines (keep max 1 blank line)
    formatted = formatted.replace(/\n{3,}/g, '\n\n');
    
    // Ensure proper spacing around DOCTYPE
    formatted = formatted.replace(/(<!DOCTYPE[^>]*>)\n+<html/gi, '$1\n<html');
    
    return formatted;
  }

  // ========================================================================
  // POST-IMPORT NORMALIZATION - Annotate editable components after import
  // ========================================================================

  /**
   * Annotates text components with editability markers after import
   * This ensures re-imported HTML remains editable even if data-gjs-* attributes were stripped
   * ENHANCED: Now includes recursive processing and comprehensive logging
   */
  function annotateEditableComponents() {
    console.log('[EDITABILITY] Starting post-import normalization...');

    try {
      const wrapper = editor.getWrapper();
      if (!wrapper) {
        console.warn('[EDITABILITY] No wrapper found for normalization');
        return;
      }

      const allComponents = wrapper.components();
      console.log('[EDITABILITY] Found', allComponents.length, 'top-level components');

      let annotatedCount = 0;
      let processedCount = 0;

      // Recursively process all components
      function processComponent(component, depth = 0) {
        processedCount++;
        const tagName = component.get('tagName')?.toLowerCase();
        const componentType = component.get('type');
        const el = component.getEl();

        console.log(`[EDITABILITY] Processing (depth ${depth}): ${tagName}, type: ${componentType}`);

        // Target text containers
        if (['td', 'th', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'a', 'span'].includes(tagName)) {
          if (el && hasTextContent(el) && !hasStructuralChildren(component)) {
            try {
              // Set component type to text
              component.set('type', 'text');
              component.set('editable', true);
              component.set('droppable', true);
              component.set('selectable', true);

              // Add editability attributes
              component.addAttributes({
                'data-gjs-type': 'text',
                'data-gjs-editable': 'true',
                'contenteditable': 'true'
              });

              annotatedCount++;
              const preview = el.textContent.substring(0, 50).replace(/\n/g, ' ');
              console.log(`[EDITABILITY]  Marked ${tagName} as editable:`, preview + '...');
            } catch (err) {
              console.error(`[EDITABILITY] Error marking ${tagName}:`, err);
            }
          } else {
            if (!el) console.log(`[EDITABILITY]  No element for ${tagName}`);
            else if (!hasTextContent(el)) console.log(`[EDITABILITY]  No text in ${tagName}`);
            else console.log(`[EDITABILITY]  Has structural children:`, tagName);
          }
        }

        // Recursively process children
        const children = component.components();
        if (children && children.length > 0) {
          children.forEach(child => processComponent(child, depth + 1));
        }
      }

      // Process all top-level components
      allComponents.forEach(component => processComponent(component, 0));

      console.log(`[EDITABILITY] Processed ${processedCount} components total`);
      console.log(`[EDITABILITY] Annotated ${annotatedCount} components as editable`);

      // Force editor refresh to apply changes
      editor.refresh();

      console.log(`[EDITABILITY] Post-import normalization complete!`);

      // If nothing was annotated, that's a problem
      if (annotatedCount === 0) {
        console.error('[EDITABILITY] WARNING: No components were annotated! This might indicate a problem.');
      }
    } catch (error) {
      console.error('[EDITABILITY] Error during normalization:', error);
    }
  }

  /**
   * Check if element has meaningful text content
   */
  function hasTextContent(el) {
    return el.textContent && el.textContent.trim().length > 0;
  }

  /**
   * Check if component has structural (non-text) children
   */
  function hasStructuralChildren(component) {
    const children = component.components();
    return children.some(child => {
      const type = child.get('type');
      return type === 'image' || type === 'video' || type === 'table';
    });
  }

  // ========================================================================
  // EDITOR READY EVENT - Load existing content when editor initializes
  // ========================================================================
  editor.onReady(function () {
    setAutosaveStatus('Loading content...', 'saving');

    const finalizeLoad = () => {
      initializeAutosaveBaseline();
    };

    if (fileId) {
      fetch(
        `/content/${fileId}?_=${new Date().getTime()}`
      )
        .then((response) => {
          if (!response.ok) {
            throw new Error('Failed to load newsletter content');
          }
          return response.text();               // Parse response as text/HTML
        })
        .then((data) => {
          // Parse the saved HTML to extract body content and styles
          try {
            // DUAL IMPORT STRATEGY: Try editor version first (with data-gjs-* attributes)
            let htmlToLoad = localStorage.getItem('newsletter_editor_html');
            let cssToLoad = localStorage.getItem('newsletter_editor_css');

            // Fallback to saved server content if no editor version exists
            if (!htmlToLoad) {
              const parser = new DOMParser();
              const doc = parser.parseFromString(data, 'text/html');

              if (doc && doc.body) {
                htmlToLoad = doc.body.innerHTML;
                cssToLoad = Array.from(doc.querySelectorAll('style'))
                  .map(s => s.textContent || '')
                  .join('\n');
              }
            }

            // Load components and styles
            if (htmlToLoad) {
              editor.setComponents(htmlToLoad);
            }

            if (cssToLoad && cssToLoad.trim()) {
              editor.setStyle(cssToLoad);
            }

            // Annotate components for editability after import
            // Use setTimeout to ensure components are fully mounted
            setTimeout(() => {
              annotateEditableComponents();
            }, 100);

            console.log('Content loaded successfully (editor version:', !!localStorage.getItem('newsletter_editor_html'), ')');
          } catch (e) {
            console.error('Failed to parse saved HTML:', e);
            // Last resort: just load the raw HTML
            editor.setComponents(data);
            setTimeout(() => {
              annotateEditableComponents();
            }, 100);
          }
        })  // Load content into editor
        .catch((error) => {
          // --- Handle Content Loading Errors ---
          console.error('Error loading content:', error);
          Swal.fire({
            icon: 'warning',
            title: 'Content Load Warning',
            text: 'Could not load existing content. Starting with empty template.',
            confirmButtonColor: '#10b981'       // Green confirm button
          });
        })
        .finally(() => finalizeLoad());
    } else {
      finalizeLoad();
    }
  });
</script>
{% endblock %}
